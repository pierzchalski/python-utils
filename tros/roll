#! /usr/bin/python3

import random
import argparse
import math

def p_le(tn):
    # can't roll less than 1
    if tn < 1:
        return 0.0
    # can't roll a multiple of 10, so rolling 10*k or less is the same as rolling
    # less than 10*k
    if tn % 10 == 0:
        return p_lt(tn)
    # derivation:
    #   say d = 10 * t + i, where 0 < i < 10 (we assume d is not a multiple
    #   of 10). To roll d, we need to get t 10's, then a single i,
    #   so P(roll = d) is ((1/10) ** t) * (1/10) == (1/10) ** (t + 1).
    #   
    #   We also have
    #     P(0 < roll < 10) = 0.9 (need to roll exactly zero 10's)
    #     P(10 < roll < 20) = 0.09 (need to roll exactly one 10)
    #     ...etc.
    #
    #   So 
    #     P(roll <= d) = P(0 < roll < 10)
    #                    + P(10 < roll < 20) 
    #                    + ...
    #                    + P(10 * t < roll <= 10 * t + i)
    #                  = 9 * (1/10)
    #                    + 9 * ((1/10) ** 2)
    #                    + ... 
    #                    + 9 * ((1/10) ** t)
    #                    + i * ((1/10) ** (t + 1))
    #   Using geometric sums:
    #     P(roll <= d) = (9/10) * ( 1 - ((1/10) ** t) )
    #                             (-------------------)
    #                             (     1 - (1/10)    )
    #                    + i * ((1/10) ** (t + 1))
    #                  = 1 + (i - 10) * ((1/10) ** (t + 1))
    return 1 + ((tn % 10) - 10) * (0.1 ** ((tn // 10) + 1))

def p_ge(tn):
    return 1 - p_lt(tn)

def p_gt(tn):
    return 1 - p_le(tn)

def p_lt(tn):
    return p_le(tn - 1)

def p_eq(tn):
    return p_le(tn) - p_lt(tn)

def p_interval(lo, hi_exclusive):
    return p_lt(hi_exclusive) - p_lt(lo)

def p_botch(lvl, tn):
    # can't botch if you can't fail.
    if tn <= 1:
        return 0.0
    # can't botch if you can't roll two 1's.
    if lvl <= 1:
        return 0.0
    # derivation:
    #   P(failure and at least two 1's)
    #       (iterating over all divisions into 1's and not-1's)
    #     = sum(i=2...lvl; lvl!/(i!(lvl-i)!) p_eq(1)**i p_interval(2, tn)**(lvl - i))
    #     = sum(i=0...lvl; ...) 
    #       - p_interval(2, tn) ** lvl 
    #       - n p_eq(1) p_interval(2, tn) ** (lvl - 1)
    #   But sum(i=0...n; ...) 
    #     = P(failure and at least zero 1's)
    #     = P(failure) = p_lt(tn) ** lvl
    return (p_lt(tn) ** lvl) - (p_interval(2, tn) ** lvl) \
        - lvl * p_eq(1) * (p_interval(2, tn) ** (lvl - 1))

def p_roll_eq(lvl, tn, s):
    # can't get more successes than rolls
    if s > lvl:
        return 0.0
    count = math.factorial(lvl) // \
        (math.factorial(s) * math.factorial(lvl - s))
    return count * (p_ge(tn) ** s) * (p_interval(1, tn) ** (lvl - s))

def roll_stack():
    roll = random.randint(1, 10)
    if roll == 10:
        return roll + roll_stack()
    return roll

def attr_subcommand(args):
    print('P(botch): {:2.3f}'.format(p_botch(args.lvl, args.tn)))
    #n_samples = 10**6
    #samples = ([roll_stack() for i in range(0, args.lvl)] \
    #    for j in range(0, n_samples))
    #s_counts = [0 for i in range(0, args.lvl + 1)]
    #def successes(rolls):
    #    return sum((1 if roll >= args.tn else 0 for roll in rolls))
    #for sample in samples:
    #    s_counts[successes(sample)] += 1
    p_accum = 0.0
    print('Probability of degrees of success:')
    for i in range(0, args.lvl + 1):
        p = p_roll_eq(args.lvl, args.tn, i)
        print('P(=={:2d}): {:2.3f}, P(>={:2d}): {:2.3f}'.format(\
            i, p, i, 1 - p_accum))
        p_accum += p

def no_subcommand(parser):
    def magic(args):
        parser.parse_args(['-h'])
    return magic

def main():
    parser = argparse.ArgumentParser(\
        description='Dice roll utilities for The Riddle of Steel')
    parser.set_defaults(func=no_subcommand(parser))
    subparsers = parser.add_subparsers()

    attr_parser = subparsers.add_parser('attr', \
        help='analyse attribute tests')
    attr_parser.add_argument('lvl', type=int, \
        help='the level of the attribute (number of dice rolled)')
    attr_parser.add_argument('tn', type=int, \
        help='target number to roll against')
    attr_parser.set_defaults(func=attr_subcommand)

    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
